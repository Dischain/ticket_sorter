# ticket_sorter

## Задание

Вам дана стопка посадочных карточек на различные виды транспорта, которые доставят вас из точки A в точку B. Карточки перепутаны, и вы не знаете, где начинается и где заканчивается ваше путешествие. Каждая карточка содержит информацию о том, откуда и куда вы едете на данном отрезке маршрута, а также о типе транспорта (номер рейса, номер места и прочее). 

Предоставьте JavaScript API, который отсортирует такой список карточек и вернет словесное описание, как проделать ваше путешествие. API должен принимать на вход несортированный список карточек в формате придуманном вами и возвращать описание маршрута.

## Решение

### Условия

На входе имеем множество карточек, каждая карточка содержит пункт отправки ```departure name``` и пункт прибытия ```destination name```, а также прочие специфичные для определенного вида транспорта данные.

Требуется эти карточки разложить в порядке, в котором ими придется воспользоваться 
при перемещении по какому-то маршруту из A в B (на самом деле, как я понял, весь интерес заключается в алгоритме, который сможет эти карточки упорядочить, а построение маршрута между городами - это уже следствие из его работы).

Условия, при которых алгоритм можно использовать:

* карточки должны образовывать неразрывную цепочку, т.е. промежуточные города не могут отсутствовать (это условие проверяется нашим API при инициализации);
* цепочка не может ветвиться, т.е. при наличии карточек А-B и B-C, карточки A-C, A-D и т.д., либо B-E, B-F и т.д.,  либо С-В, B-A существовать не могут (об этом уще будут даны замечания в конце).

Теперь, исходя из условий, мы можем прийти к выводу, что структура данных, образуемая карточками, представляет связанный список (хотя поначалу может показаться, что это дорожный граф), и мы можем формализовать задачу.

### Формализация

Формально, мы имеем множество элементов связанного списка, где вместо ```next```  (который является ссылкой на следующий элемент), используется значение имени города, в который данная карточка осуществляет перемещение(```destination```). Важно отметить, что если допустить возможность перемещения в обратном направлении (от ```destination``` к ```departure```), то список становится двусвязным.

Для того, чтобы из этих элементов выстроить неразрывную цепочку, во-первых, решим, что карточки приходят к нам в виде массива. Тогда нам нужно отображениe вида ```( KEY : [departure] ) <-> ( VALUE : [card] )```, которое позволит быстро извлекать из массива карточку с указанным ```departure```. Для этого построим хэш таблицу ```forwardOrderedHT```, где ключем будет ```departure name``` города, а значением - индекс карточки в массиве карточек (получается эдакая нормализация :)

### Построение пути

Теперь задача построения пути становится тривиальной:
 
1. Берем карточку с указанным местом отправки.
2. Пока пункт назначения данной карточки не является требуемым пунктом, помещаем индекс текущей карточки в массив и заменяем текущую карточку на карточку, соответствующую пункту назначения текущей карточки.
3. Повторяем, пока условие цикла истинно. В результате в массиве будут храниться индексы отсортированных карточек.

### Сортировка

Так как для выполнения сортировки необходимо знать первую карточку в маршруте,
добавим еще одну хэш-таблицу, которая будет хранить индексы карточек в обратном порядке - ```backOrderedHT```, где ключем теперь будет являться пункт назначения ```destination name```. Алгоритм сортировки слeдующий:

1. Получаем случайный индекс - число, лежащее в диапазоне от нуля до длины массива карточек.
2. От карточки, расположенной по этому индексу, перемещаемся в обратном направлении, насколько хватает карточек, используя ```backOrderedHT```, чтобы найти самую первую карточку.
1. Затем, зная первую карточку, перемещаемся от нее в прямом направлении, до самой последней карточки, попутно сохраняя индексы.

### Использование

Добавьте ts.js к проекту:
```<script type="text/javascript" src="ts.js"></script>```

И подключите свой скрипт с таким содержанием:

```
ts.initialize(tickets, phrasesConfig, callback).sort().prettyPrint(console.log);
```

Более полный пример см. в [examples](https://github.com/Dischain/ticket_sorter/tree/master/example)

### Методы API

#### ```ts.initialize(tickets, phrasesConfig, callback)```

Импортирует массив карточек ```tickets``` и ```phrasesConfig```, определяющий фразы для отображения карточек при вызове ```prettyPrint()```. Аргумент ```phrasesConfig``` может быть опущен, в таком случае будут использоваться определенные в API фразы по умолчанию - ```defaultPhrasesConfig```. ```callback``` - функция, принимающая аргумент с ```error``` - информацией об ошибке, которая может возникнуть при отсутствии необходимых полей в объекте карточки. ```error.message``` содержит описание ошибки, ```error.invalidTicketsIndexes``` - массив с индексами карточек, в которых обнаружена ошибка. Возвращает объект ```ts``` для реализации цепочки вызовов.

#### ```ts.sort(callback)```

Сортирует карточки в порядке от первого пункта отправки до последнего пункта назначения и сохраняет отсортированный массив индексов в локальные переменные ```lastBuiltPath```, к которой обращается ```prettyPrint()```, и ```sortedTickets```, предусмотренную для работы с уже отсортированным массивом. Принимает необязательную функцию обратного вызова ```callback```, в которую в качестве аргумента передается ```sortedTickets```. Возвращает объект ```ts``` для реализации цепочки вызовов.

#### ```ts.buildPath(from, to, callback)```

Формирует маршрут из карточек в порядке от первого пункта отправки ```from``` до последнего пункта назначения ```to``` и сохраняет построенный массив индексов в локальную переменную ```lastBuiltPath```, к которой обращается ```prettyPrint()```. Принимает необязательную функцию обратного вызова ```callback```, в которую в качестве аргумента передается lastBuiltPath. Возвращает объект ```ts``` для реализации цепочки вызовов.

#### ```ts.prettyPrint(callback)```

Формирует массив строк, построенных по определенному в этом API правилу вывода для билетов и передает его в ```callback```.

### Формат данных

Формат данных предусматривает обязательное наличие полей ```departure.name``` и ```destination.name```. Остальные параметры необязательны.

    [
      {
        transport: {
          type: <transportType>
          routeNumber: <transportNumber>,
          seat: <seatNumber>,
          gate: <gateNumber>,
          baggage: <baggageNumber>
        },
        departure: {
          name: <departureName>
        },
        destination: {
          name: <destinationName>
        }
      }
    ]

Для конфигурирования вывода может быть указан ```phrasesConfig```, представляющий объект с фразами, которые будут выводиться для описания тех или иных полей в объекте карточки. Формат ```phrasesConfig```:

    {
      <transportType>: {
        action: <actionType>
      },
      common: {
        commonAction: <commonActionType>,
        commonTransport: '<commonTransportType>',

        seatPhrase: <seatPhrase>,
        defaultSeatPhrase: <defaultSeatPhrase>,

        baggagePhrase: <baggagePhrase>,
        defaultBaggagePhrase: <defaultBaggagePhrase>,

        gatePhrase: <gatePhrase>,
        defaultGatePhrase: <defaultGatePhrase>
      }
    }

Описание карточки выводится в соответствие со следующим правилом:

    <rule> = <actionType> <transportType> <transportNumber>
		| <commonActionType> <commonTransportType>
		'from' <departureName> 'to' <destinationName>. 
 		<gatePhrase> <gateNumber> | <defaultGatePhrase>.
		<seatPhrase> <seatNumber> | <defaultSeatPhrase>.
 		<baggagePhrase> <baggageNumber> | <defaultBaggagePhrase>.

### Замечения

Структура данный рассматриваемой задачи, семантически, тем не менее, должна рассматриваться как граф. В данном случае получившийся связный список является просто результатом вырождения графа, ограниченного поставленными [условиями](https://github.com/Dischain/ticket_sorter/blob/master/README.md#Условия).

В более общем случае решение должно было бы справляться со случаями цикличности (есть билеты из А в B и из B в A) и выбором оптимального маршрута (есть два билета из A в B и из B в C, и есть билет сразу из A в C).

Такой подход я использовал для построения иерархической структуры каталогов,
только в хэш таблицу заносились не имена, а адреса каталогов и их индексы, 
после чего по индексам строилась матрица смежности.